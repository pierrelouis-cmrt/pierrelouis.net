<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --glass-bg: rgba(255, 255, 255, 0.05);
        --glass-border: rgba(255, 255, 255, 0.08);
        --glass-blur: 6px;
        --text: #e9eef5;
        --muted: #cdd5df;
        --bg: #131417;
        --canvas-bg: #191b1f;

        --space-xs: clamp(6px, 1.2vw, 10px);
        --space-sm: clamp(10px, 2.2vw, 14px);
        --space-md: clamp(14px, 3.2vw, 18px);
        --space-lg: clamp(18px, 4.2vw, 26px);
        --space-xl: clamp(22px, 5.2vw, 34px);

        --text-xs: clamp(11px, 2.8vw, 12px);
        --text-sm: clamp(12px, 3vw, 13.5px);
        --text-base: clamp(13px, 3.2vw, 15px);
        --text-lg: clamp(14px, 3.4vw, 16px);

        --border-radius-sm: clamp(6px, 1.5vw, 8px);
        --border-radius-md: clamp(8px, 2vw, 10px);
        --border-radius-lg: clamp(10px, 2.5vw, 14px);
        --border-radius-xl: clamp(12px, 3vw, 16px);

        --z-controls: 10;
      }

      html,
      body {
        padding: 0;
        margin: 0;
        overflow: hidden;
        height: 100%;
        width: 100%;
        background: var(--bg);
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial;
      }

      #container {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        height: 100dvh;
        overflow: hidden;
        background: radial-gradient(
          1300px 950px at 65% -10%,
          #2a2c31 0%,
          #1a1c20 45%,
          #14161a 100%
        );
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      #container,
      #container canvas {
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
      }

      .hint {
        position: absolute;
        top: var(--space-md);
        left: 50%;
        transform: translateX(-50%);
        font-size: var(--text-sm);
        letter-spacing: 0.3px;
        color: var(--muted);
        padding: var(--space-sm) var(--space-md);
        border-radius: 999px;
        background: var(--glass-bg);
        backdrop-filter: blur(var(--glass-blur));
        -webkit-backdrop-filter: blur(var(--glass-blur));
        box-shadow: inset 0 0 0 1px var(--glass-border);
        pointer-events: none;
        max-width: max-content;
        width: 80vw;
        text-align: center;
        line-height: 1.4;
        z-index: 5;
      }

      @media (pointer: coarse) {
        .hint span {
          display: none;
        }
      }

      .kbd {
        padding: 2px clamp(5px, 1.5vw, 7px);
        padding-right: clamp(3px, 1.5vw, 5px);
        background: rgba(255, 255, 255, 0.08);
        border-radius: var(--border-radius-sm);
        border: 1px solid rgba(255, 255, 255, 0.12);
        margin: 0 2px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: var(--text-xs);
      }

      .controls {
        position: absolute;
        bottom: var(--space-md);
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        gap: clamp(8px, 2.5vw, 12px);
        flex-wrap: wrap;
        justify-content: center;
        padding: 10px;
        border-radius: var(--border-radius-lg);
        background: var(--glass-bg);
        backdrop-filter: blur(var(--glass-blur));
        -webkit-backdrop-filter: blur(var(--glass-blur));
        box-shadow: inset 0 0 0 1px var(--glass-border);
        width: 80vw;
        max-width: max-content;
        z-index: var(--z-controls);
      }

      .chip {
        width: clamp(24px, 6vw, 28px);
        height: clamp(24px, 6vw, 28px);
        max-width: 40px !important;
        max-height: 40px !important;
        border-radius: var(--border-radius-md);
        position: relative;
        cursor: pointer;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.22),
          0 2px 10px rgba(0, 0, 0, 0.3);
        transition: transform 150ms ease, box-shadow 150ms ease;
        overflow: hidden;
        flex-shrink: 0;
      }

      .chip:hover {
        transform: translateY(-2px);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.28),
          0 6px 20px rgba(0, 0, 0, 0.35);
      }

      .chip input {
        position: absolute;
        inset: 0;
        opacity: 0;
        cursor: pointer;
      }

      .btn {
        appearance: none;
        border: none;
        outline: none;
        cursor: pointer;
        font-size: var(--text-sm);
        font-weight: 600;
        letter-spacing: 0.25px;
        color: var(--text);
        padding: clamp(6px, 2vw, 8px) clamp(8px, 2.5vw, 12px);
        border-radius: var(--border-radius-md);
        background: var(--glass-bg);
        backdrop-filter: blur(var(--glass-blur));
        -webkit-backdrop-filter: blur(var(--glass-blur));
        box-shadow: inset 0 0 0 1px var(--glass-border),
          0 6px 18px rgba(0, 0, 0, 0.3);
        transition: transform 140ms ease, box-shadow 140ms ease;
        white-space: nowrap;
        min-height: clamp(30px, 7.5vw, 36px);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .btn:hover {
        transform: translateY(-1px);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.18),
          0 10px 22px rgba(0, 0, 0, 0.36);
      }

      .btn:active {
        transform: translateY(0);
      }

      .btn.sm {
        padding: clamp(4px, 1.5vw, 6px) clamp(8px, 2vw, 10px);
        font-size: var(--text-xs);
        min-height: clamp(28px, 7vw, 32px);
      }

      @media (max-width: 480px) {
        .controls {
          gap: 6px;
          flex-direction: row;
        }
        .chip {
          width: 22px;
          height: 22px;
        }
        .btn {
          padding: 4px 8px;
          font-size: 11px;
          min-height: 28px;
        }
        .btn span {
          display: none;
        }
        .btn {
          min-height: 44px;
          min-width: 44px;
        }
      }

      @media (max-width: 768px) and (min-width: 481px) {
        .controls {
          flex-wrap: nowrap;
          overflow-x: auto;
          scrollbar-width: none;
          -ms-overflow-style: none;
        }
        .controls::-webkit-scrollbar {
          display: none;
        }
      }

      @media (max-height: 500px) and (orientation: landscape) {
        .controls {
          bottom: 8px;
        }
      }

      @media (min-resolution: 2dppx) {
        .hint,
        .controls {
          backdrop-filter: blur(6px);
          -webkit-backdrop-filter: blur(6px);
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .btn,
        .chip {
          transition: none;
        }
      }

      @media (hover: none) and (pointer: coarse) {
        .btn,
        .chip {
          min-height: 44px;
        }
        .chip {
          min-width: 44px;
        }
      }
    </style>
  </head>
  <body>
    <div id="container">
      <canvas></canvas>

      <div class="hint">
        Tap to bloom. Drag to illuminate.
        <span
          >Hover to interact. <br />Press <span class="kbd">R</span> to
          randomize & bloom at cursor.</span
        >
      </div>

      <div class="controls">
        <label class="chip" title="Color A"
          ><input type="color" id="colorA" value="#ff6b6b"
        /></label>
        <label class="chip" title="Color B"
          ><input type="color" id="colorB" value="#ffd166"
        /></label>
        <label class="chip" title="Color C"
          ><input type="color" id="colorC" value="#5dd3ff"
        /></label>
        <button class="btn" id="randomBtn" title="Random beautiful palette">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="lucide lucide-shuffle"
          >
            <path d="m18 14 4 4-4 4" />
            <path d="m18 2 4 4-4 4" />
            <path
              d="M2 18h1.973a4 4 0 0 0 3.3-1.7l5.454-8.6a4 4 0 0 1 3.3-1.7H22"
            />
            <path d="M2 6h1.972a4 4 0 0 1 3.6 2.2" />
            <path d="M22 18h-6.041a4 4 0 0 1-3.3-1.8l-.359-.45" />
          </svg>
          <span style="margin-left: 0.5rem; padding-bottom: 2px">Random</span>
        </button>
      </div>
    </div>

    <script>
      const canvas = document.querySelector("canvas");
      const container = document.querySelector("#container");
      const controls = document.querySelector(".controls");
      const ctx = canvas.getContext("2d", { alpha: false });

      const colorA = document.getElementById("colorA");
      const colorB = document.getElementById("colorB");
      const colorC = document.getElementById("colorC");
      const randomBtn = document.getElementById("randomBtn");

      let width = 0,
        height = 0,
        pixels = [];
      let request = null,
        lastTime = 0;
      const interval = 1000 / 60;

      let ticker = 0,
        maxTicker = 360,
        animationDirection = 0;

      let origin = { x: 0, y: 0 };
      let mouse = { x: -9999, y: -9999, inside: false };

      // Smoothed mouse velocity
      let v = { vx: 0, vy: 0, px: -9999, py: -9999 };
      const speedRef = 1200;
      const speedAlpha = 0.25;

      // Cursor trail
      const TRAIL_LEN = 14;
      const trailX = new Float32Array(TRAIL_LEN);
      const trailY = new Float32Array(TRAIL_LEN);
      const trailW = new Float32Array(TRAIL_LEN);
      let activity = 0;

      // Inertia when cursor stops / leaves
      let ghost = { x: 0, y: 0 };
      const inertiaFactor = 0.95;

      let gap = 6,
        stepBase = 0,
        gapAuto = true;
      let userPalette = ["#ff6b6b", "#ffd166", "#5dd3ff"];

      const cfg = {
        baseRadiusMin: 40,
        radiusMultiplier: 1,
        sizeBoostFactor: 0.3,
        lBoostMax: 9,
      };

      // ★ Detect touch environment
      const isTouchEnv =
        window.matchMedia &&
        (matchMedia("(hover: none)").matches ||
          matchMedia("(pointer: coarse)").matches);

      // ═══════════════════════════════════════════════════════════════════
      // ★ TOUCH SYSTEM - Soft illumination trail
      // ═══════════════════════════════════════════════════════════════════
      let touch = {
        active: false,
        x: 0,
        y: 0,
        px: 0,
        py: 0,
        vx: 0,
        vy: 0,
        downX: 0,
        downY: 0,
        moved: false,
      };

      // Longer touch trail for smooth, flowing effect
      const TOUCH_TRAIL_LEN = 24;
      const touchTrailX = new Float32Array(TOUCH_TRAIL_LEN);
      const touchTrailY = new Float32Array(TOUCH_TRAIL_LEN);
      const touchTrailW = new Float32Array(TOUCH_TRAIL_LEN);
      let touchActivity = 0;

      // Pulse wave on release
      let pulseWave = {
        active: false,
        x: 0,
        y: 0,
        radius: 0,
        maxRadius: 0,
        strength: 0,
      };

      // ═══════════════════════════════════════════════════════════════════

      // --- Utils ---
      const rand = (min, max) => Math.random() * (max - min) + min;
      const clamp01 = (v) => Math.max(0, Math.min(1, v));

      function hexToRgb(hex) {
        let h = hex.replace("#", "");
        if (h.length === 3)
          h = h
            .split("")
            .map((c) => c + c)
            .join("");
        const n = parseInt(h, 16);
        return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
      }
      function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b),
          min = Math.min(r, g, b);
        let h,
          s,
          l = (max + min) / 2;
        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h *= 60;
        }
        return {
          h: Math.round(h),
          s: Math.round(s * 100),
          l: Math.round(l * 100),
        };
      }
      function hslToRgb(h, s, l) {
        s /= 100;
        l /= 100;
        const k = (n) => (n + h / 30) % 12;
        const a = s * Math.min(l, 1 - l);
        const f = (n) =>
          l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
        return {
          r: Math.round(255 * f(0)),
          g: Math.round(255 * f(8)),
          b: Math.round(255 * f(4)),
        };
      }
      const rgbToHex = (r, g, b) =>
        "#" + [r, g, b].map((c) => c.toString(16).padStart(2, "0")).join("");
      const makeHsl = (h, s, l) =>
        `hsl(${((h % 360) + 360) % 360}, ${Math.round(s)}%, ${Math.round(l)}%)`;
      function parseHsl(hslStr) {
        const m = hslStr
          .replace(/,/g, " ")
          .match(/^hsl\(\s*([\d.]+)\s+([\d.]+)%\s+([\d.]+)%\s*\)$/i);
        if (!m) return { h: 0, s: 0, l: 50 };
        return {
          h: parseFloat(m[1]),
          s: parseFloat(m[2]),
          l: parseFloat(m[3]),
        };
      }
      const toHexFromHsl = (h, s, l) => {
        const { r, g, b } = hslToRgb(h, s, l);
        return rgbToHex(r, g, b);
      };

      function hexToHslStr(hex) {
        const { r, g, b } = hexToRgb(hex);
        const { h, s, l } = rgbToHsl(r, g, b);
        return makeHsl(h, s, l);
      }
      function getActivePalette() {
        return userPalette.map(hexToHslStr);
      }

      // Random palettes
      function randomLovelyPalette() {
        const base = Math.floor(rand(0, 360));
        const schemes = ["analogous", "complement", "split", "triadic", "mono"];
        const scheme = schemes[(Math.random() * schemes.length) | 0];

        const sMain = rand(72, 92);
        const lMain = rand(54, 66);

        let hs = [];
        if (scheme === "analogous") {
          const spread = rand(22, 40);
          hs = [base, base + spread, base - spread];
        } else if (scheme === "complement") {
          const comp = (base + 180) % 360;
          const accent =
            base + (Math.random() < 0.5 ? 30 : -30) * rand(0.8, 1.2);
          hs = [base, comp, accent];
        } else if (scheme === "split") {
          hs = [base, base + 150, base + 210];
        } else if (scheme === "triadic") {
          hs = [base, base + 120, base + 240];
        } else {
          hs = [base, base, base];
        }

        const colors = hs.map((h, i) => {
          const s = clamp01((sMain + rand(-6, 6)) / 100) * 100;
          const l =
            scheme === "mono"
              ? clamp01((lMain + [-10, 0, +10][i] + rand(-3, 3)) / 100) * 100
              : clamp01((lMain + rand(-6, 6)) / 100) * 100;
          return toHexFromHsl(h, s, l);
        });

        colorA.value = colors[0];
        colorB.value = colors[1];
        colorC.value = colors[2];
        userPalette = [...colors];
        paintChipBackgrounds();
        return colors;
      }

      class Pixel {
        constructor(
          x,
          y,
          colorHslStr,
          maxSize,
          delayShow,
          delayHide,
          speed,
          step
        ) {
          this.x = x;
          this.y = y;
          const { h, s, l } = parseHsl(colorHslStr);
          this.h = h;
          this.s = s;
          this.lBase = l;

          this.size = 0;
          this.sizeMin = 0.4;
          this.sizeMax = maxSize;
          this.sizeFlickStep = rand(0.01, 0.35);
          this.speed = rand(0.1, 0.9) * speed;
          this.sizeDirection = 1;

          this.delayShow = delayShow;
          this.delayHide = delayHide;
          this.counterShow = 0;
          this.counterHide = 0;
          this.counterStep = step;

          this.sizeBoost = 0;
          this.lBoost = 0;

          this.isHidden = true;
          this.isFlicking = false;
        }

        updateHover(params) {
          const {
            R2,
            invR2,
            trailX,
            trailY,
            trailW,
            trailN,
            sizeBoostMax,
            lBoostMax,
          } = params;
          let acc = 0;
          for (let i = 0; i < trailN; i++) {
            const dx = this.x - trailX[i];
            const dy = this.y - trailY[i];
            const d2 = dx * dx + dy * dy;
            const k = 1 / (1 + d2 * invR2);
            acc += trailW[i] * k;
          }
          const w = Math.min(1, acc);
          const targetSize = w * sizeBoostMax;
          const targetL = w * lBoostMax;
          this.sizeBoost += (targetSize - this.sizeBoost) * 0.35;
          this.lBoost += (targetL - this.lBoost) * 0.35;
          if (w < 0.001) {
            this.sizeBoost *= 0.85;
            this.lBoost *= 0.85;
            if (this.sizeBoost < 0.01) this.sizeBoost = 0;
            if (this.lBoost < 0.01) this.lBoost = 0;
          }
        }

        // Pulse wave effect - gentle outward ripple
        updatePulse(pulse) {
          if (!pulse.active) return;
          const dx = this.x - pulse.x;
          const dy = this.y - pulse.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Wave band - pixels light up as wave passes through them
          const waveWidth = 60;
          const distFromWave = Math.abs(dist - pulse.radius);

          if (distFromWave < waveWidth) {
            const intensity = (1 - distFromWave / waveWidth) * pulse.strength;
            this.lBoost = Math.max(this.lBoost, intensity * 12);
            this.sizeBoost = Math.max(this.sizeBoost, intensity * gap * 0.3);
          }
        }

        draw(ctx) {
          const sizeNow = Math.max(0, this.size + this.sizeBoost);
          const offset = this.sizeMax * 0.5 - sizeNow * 0.5;
          const L = Math.min(100, this.lBase + this.lBoost);
          ctx.fillStyle = makeHsl(this.h, this.s, L);
          ctx.fillRect(this.x + offset, this.y + offset, sizeNow, sizeNow);
        }

        show() {
          this.isHidden = false;
          this.counterHide = 0;
          if (this.counterShow <= this.delayShow) {
            this.counterShow += this.counterStep;
            if (this.isFlicking) this.flicking();
            return;
          }
          if (this.size >= this.sizeMax) this.isFlicking = true;
          if (this.isFlicking) this.flicking();
          else this.size += this.sizeFlickStep;
        }

        hide() {
          this.counterShow = 0;
          if (this.counterHide <= this.delayHide) {
            this.counterHide += this.counterStep;
            if (this.isFlicking) this.flicking();
            return;
          }
          this.isFlicking = false;
          if (this.size <= 0) {
            this.size = 0;
            this.isHidden = true;
            return;
          }
          this.size -= 0.05;
        }

        flicking() {
          if (this.size >= this.sizeMax) this.sizeDirection = -1;
          else if (this.size <= this.sizeMin) this.sizeDirection = 1;
          this.size += this.sizeDirection * this.speed;
        }
      }

      function getDelayFromOrigin(x, y) {
        const dx = x - origin.x,
          dy = y - origin.y;
        return Math.sqrt(dx * dx + dy * dy);
      }

      function initPixels() {
        const palette = getActivePalette();
        const colorsLen = palette.length;
        pixels = [];

        const diag = Math.hypot(width, height);
        maxTicker = Math.max(240, Math.min(640, Math.floor(diag * 0.45)));

        for (let x = 0; x < width; x += gap) {
          for (let y = 0; y < height; y += gap) {
            const maxSize = Math.max(2, Math.floor(gap * 0.5));
            const color = palette[((x / gap + y / gap) | 0) % colorsLen];
            const delay = getDelayFromOrigin(x, y);
            pixels.push(
              new Pixel(
                x,
                y,
                color,
                maxSize,
                delay,
                delay,
                rand(0.08, 0.25),
                stepBase
              )
            );
          }
        }
      }

      function animate() {
        request = requestAnimationFrame(animate);

        const now = performance.now();
        const diff = now - (lastTime || 0);
        if (diff < interval) return;

        const dt = Math.min(0.05, diff / 1000);
        lastTime = now - (diff % interval);

        // ─────────────────────────────────────────────────────────────────
        // DESKTOP MOUSE HANDLING
        // ─────────────────────────────────────────────────────────────────
        if (!isTouchEnv) {
          if (v.px !== -9999) {
            const ivx = (mouse.x - v.px) / dt;
            const ivy = (mouse.y - v.py) / dt;
            v.vx += (ivx - v.vx) * speedAlpha;
            v.vy += (ivy - v.vy) * speedAlpha;
          }
          v.px = mouse.x;
          v.py = mouse.y;

          if (mouse.inside) {
            ghost.x = mouse.x;
            ghost.y = mouse.y;
          } else {
            ghost.x += v.vx * dt;
            ghost.y += v.vy * dt;
            v.vx *= inertiaFactor;
            v.vy *= inertiaFactor;
          }
          if (ghost.x < 0) ghost.x = 0;
          else if (ghost.x > width) ghost.x = width;
          if (ghost.y < 0) ghost.y = 0;
          else if (ghost.y > height) ghost.y = height;

          const speed = Math.hypot(v.vx, v.vy);
          const ns = clamp01(speed / speedRef);
          activity += (ns > activity ? 0.2 : 0.08) * (ns - activity);

          for (let i = TRAIL_LEN - 1; i > 0; i--) {
            trailX[i] = trailX[i - 1];
            trailY[i] = trailY[i - 1];
          }
          trailX[0] = ghost.x;
          trailY[0] = ghost.y;

          const base = 0.42 + 0.45 * activity;
          const gamma = 1.5;
          for (let i = 0; i < TRAIL_LEN; i++) {
            const t = 1 - i / (TRAIL_LEN - 1 || 1);
            trailW[i] = base * Math.pow(t, gamma);
          }
        }

        // ─────────────────────────────────────────────────────────────────
        // TOUCH HANDLING - Soft illumination
        // ─────────────────────────────────────────────────────────────────
        if (isTouchEnv) {
          if (touch.active) {
            // Smooth velocity
            const dx = touch.x - touch.px;
            const dy = touch.y - touch.py;
            touch.vx = touch.vx * 0.7 + dx * 0.3;
            touch.vy = touch.vy * 0.7 + dy * 0.3;
            touch.px = touch.x;
            touch.py = touch.y;

            // Update trail - follows finger smoothly
            for (let i = TOUCH_TRAIL_LEN - 1; i > 0; i--) {
              touchTrailX[i] = touchTrailX[i - 1];
              touchTrailY[i] = touchTrailY[i - 1];
            }
            touchTrailX[0] = touch.x;
            touchTrailY[0] = touch.y;

            // Activity based on speed
            const speed = Math.hypot(touch.vx, touch.vy);
            const ns = clamp01(speed / 30);
            touchActivity +=
              (ns > touchActivity ? 0.3 : 0.12) * (ns - touchActivity);

            // Weight distribution - brighter at finger, fading along trail
            const base = 0.5 + 0.45 * touchActivity;
            for (let i = 0; i < TOUCH_TRAIL_LEN; i++) {
              const t = 1 - i / (TOUCH_TRAIL_LEN - 1 || 1);
              // Smooth cubic falloff for elegant trail
              touchTrailW[i] = base * t * t * t;
            }
          } else {
            // Gentle fade when not touching
            touchActivity *= 0.92;
            for (let i = 0; i < TOUCH_TRAIL_LEN; i++) {
              touchTrailW[i] *= 0.88;
            }
          }

          // Update pulse wave
          if (pulseWave.active) {
            pulseWave.radius += 8;
            pulseWave.strength *= 0.97;
            if (
              pulseWave.radius > pulseWave.maxRadius ||
              pulseWave.strength < 0.01
            ) {
              pulseWave.active = false;
            }
          }
        }

        ctx.fillStyle = "#191B1F";
        ctx.fillRect(0, 0, width, height);

        let params = null;

        // Desktop hover params
        if (!isTouchEnv) {
          const Rraw = Math.max(cfg.baseRadiusMin, gap * cfg.radiusMultiplier);
          const Rcap = 0.16 * Math.min(width, height);
          const R = Math.min(Rraw, Rcap);
          const R2 = R * R;

          params = {
            R2,
            invR2: 1 / R2,
            sizeBoostMax: Math.min(
              gap * cfg.sizeBoostFactor,
              Math.max(1, gap * 0.75)
            ),
            lBoostMax: Math.min(cfg.lBoostMax, 28),
            trailX,
            trailY,
            trailW,
            trailN: TRAIL_LEN,
          };
        }

        // Touch params - smaller, softer radius
        if (isTouchEnv && (touch.active || touchActivity > 0.01)) {
          const Rraw = Math.max(
            cfg.baseRadiusMin * 1.2,
            gap * cfg.radiusMultiplier * 1.4
          );
          const Rcap = 0.16 * Math.min(width, height);
          const R = Math.min(Rraw, Rcap);
          const R2 = R * R;

          params = {
            R2,
            invR2: 1 / R2,
            sizeBoostMax: Math.min(gap * cfg.sizeBoostFactor * 1.2, gap * 0.7),
            lBoostMax: Math.min(cfg.lBoostMax * 1.3, 18),
            trailX: touchTrailX,
            trailY: touchTrailY,
            trailW: touchTrailW,
            trailN: TOUCH_TRAIL_LEN,
          };
        }

        let allHidden = true;

        for (let i = 0; i < pixels.length; i++) {
          const p = pixels[i];

          // Apply hover/touch effect
          if (params) {
            if (!isTouchEnv) {
              if (mouse.inside || activity > 0.01) p.updateHover(params);
              else {
                p.sizeBoost *= 0.85;
                p.lBoost *= 0.85;
                if (p.sizeBoost < 0.01) p.sizeBoost = 0;
                if (p.lBoost < 0.01) p.lBoost = 0;
              }
            } else {
              if (touch.active || touchActivity > 0.01) {
                p.updateHover(params);
              } else {
                p.sizeBoost *= 0.88;
                p.lBoost *= 0.88;
                if (p.sizeBoost < 0.01) p.sizeBoost = 0;
                if (p.lBoost < 0.01) p.lBoost = 0;
              }
            }
          }

          // Apply pulse wave effect
          if (isTouchEnv && pulseWave.active) {
            p.updatePulse(pulseWave);
          }

          if (animationDirection > 0) p.show();
          else if (animationDirection < 0) {
            p.hide();
            allHidden = allHidden && p.isHidden;
          } else if (p.isFlicking) p.flicking();

          p.draw(ctx);
        }

        if (animationDirection !== 0) {
          ticker += animationDirection;
          if (animationDirection > 0 && ticker >= maxTicker)
            animationDirection = -1;
          else if (animationDirection < 0 && allHidden) {
            animationDirection = 0;
            ticker = 0;
          }
        }
      }

      function computeAutoGap(targetCount = 10000) {
        const area = width * height;
        const ideal = Math.sqrt(area / targetCount);
        const min = 10,
          max = 14;
        return Math.max(min, Math.min(max, Math.round(ideal)));
      }

      function resize() {
        if (request) cancelAnimationFrame(request), (request = null);

        width = window.innerWidth | 0;
        height = window.innerHeight | 0;

        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        stepBase = (width + height) * 0.005;

        const cx = width * 0.5,
          cy = height * 0.5;
        ghost.x = cx;
        ghost.y = cy;
        for (let i = 0; i < TRAIL_LEN; i++) {
          trailX[i] = cx;
          trailY[i] = cy;
          trailW[i] = 0;
        }
        for (let i = 0; i < TOUCH_TRAIL_LEN; i++) {
          touchTrailX[i] = cx;
          touchTrailY[i] = cy;
          touchTrailW[i] = 0;
        }

        if (gapAuto) gap = computeAutoGap();

        if (!request) animate();
      }

      // Shared bloom helper
      function bloomAt(x, y) {
        origin.x = (x + 0.5) | 0;
        origin.y = (y + 0.5) | 0;
        initPixels();
        ticker = 0;
        animationDirection = 1;
      }

      // Guard: ignore container events that originate from the controls area
      function eventFromControls(e) {
        return !!(
          e.target &&
          e.target.closest &&
          e.target.closest(".controls")
        );
      }

      // --- Desktop mouse events ---
      if (!isTouchEnv) {
        container.addEventListener("click", (e) => {
          if (eventFromControls(e)) return;
          const rect = container.getBoundingClientRect();
          bloomAt(e.clientX - rect.left, e.clientY - rect.top);
        });
        container.addEventListener("mousemove", (e) => {
          const rect = container.getBoundingClientRect();
          mouse.x = e.clientX - rect.left;
          mouse.y = e.clientY - rect.top;
          mouse.inside = !eventFromControls(e);
        });
        container.addEventListener("mouseleave", () => {
          mouse.inside = false;
        });
      } else {
        // ─────────────────────────────────────────────────────────────────
        // TOUCH EVENTS - Elegant illumination
        // ─────────────────────────────────────────────────────────────────

        container.addEventListener(
          "pointerdown",
          (e) => {
            if (eventFromControls(e)) return;
            e.preventDefault();

            const rect = container.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            touch.active = true;
            touch.x = x;
            touch.y = y;
            touch.px = x;
            touch.py = y;
            touch.vx = 0;
            touch.vy = 0;
            touch.downX = x;
            touch.downY = y;
            touch.moved = false;

            // Initialize trail at touch point
            for (let i = 0; i < TOUCH_TRAIL_LEN; i++) {
              touchTrailX[i] = x;
              touchTrailY[i] = y;
              touchTrailW[i] = 0;
            }

            // Bloom from touch point
            bloomAt(x, y);
          },
          { passive: false }
        );

        container.addEventListener(
          "pointermove",
          (e) => {
            if (!touch.active) return;
            if (eventFromControls(e)) return;
            e.preventDefault();

            const rect = container.getBoundingClientRect();
            touch.x = e.clientX - rect.left;
            touch.y = e.clientY - rect.top;
            if (!touch.moved) {
              const dx = touch.x - touch.downX;
              const dy = touch.y - touch.downY;
              touch.moved = dx * dx + dy * dy > 36;
            }
          },
          { passive: false }
        );

        function handleTouchEnd(e) {
          if (!touch.active) return;
          const speed = Math.hypot(touch.vx, touch.vy);

          // Trigger a soft pulse wave on release
          pulseWave.active = true;
          pulseWave.x = touch.x;
          pulseWave.y = touch.y;
          pulseWave.radius = 0;
          pulseWave.maxRadius = Math.max(width, height) * 0.6;
          // Stronger pulse if released with velocity
          pulseWave.strength = 0.4 + Math.min(0.6, speed * 0.03);

          touch.active = false;
          for (let i = 0; i < TOUCH_TRAIL_LEN; i++) {
            touchTrailW[i] = 0;
          }
          if (touch.moved) animationDirection = -1;
        }

        container.addEventListener("pointerup", handleTouchEnd);
        container.addEventListener("pointercancel", handleTouchEnd);
        container.addEventListener("pointerleave", handleTouchEnd);

        container.addEventListener("contextmenu", (e) => e.preventDefault());
      }

      function paintChipBackgrounds() {
        [colorA, colorB, colorC].forEach((input) => {
          input.parentElement.style.background = input.value;
        });
      }
      function syncUserPalette() {
        userPalette = [colorA.value, colorB.value, colorC.value];
        paintChipBackgrounds();
      }
      colorA.addEventListener("input", syncUserPalette);
      colorB.addEventListener("input", syncUserPalette);
      colorC.addEventListener("input", syncUserPalette);

      let randomLock = false;
      function getEventXYRelativeToContainer(e) {
        const rect = container.getBoundingClientRect();
        if (typeof e.clientX === "number" && typeof e.clientY === "number") {
          return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        const t =
          e.touches && e.touches[0]
            ? e.touches[0]
            : e.changedTouches && e.changedTouches[0];
        if (t) return { x: t.clientX - rect.left, y: t.clientY - rect.top };
        return { x: rect.width * 0.5, y: rect.height * 0.5 };
      }
      function handleRandom(e) {
        if (randomLock) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        randomLock = true;
        setTimeout(() => (randomLock = false), 250);

        e.preventDefault();
        e.stopPropagation();

        const { x, y } = getEventXYRelativeToContainer(e);
        randomLovelyPalette();
        bloomAt(x, y);

        touch.active = false;
      }
      randomBtn.addEventListener("touchstart", handleRandom, {
        passive: false,
        capture: true,
      });
      randomBtn.addEventListener("pointerdown", handleRandom, {
        passive: false,
        capture: true,
      });
      randomBtn.addEventListener("mousedown", handleRandom, { capture: true });
      randomBtn.addEventListener("click", handleRandom, { capture: true });

      // Startup
      window.addEventListener("resize", resize);
      resize();
      paintChipBackgrounds();
      syncUserPalette();
      randomLovelyPalette();

      // Keyboard (desktop): R → randomize palette & bloom at cursor
      document.addEventListener("keydown", (e) => {
        if ((e.key === "r" || e.key === "R") && !e.repeat) {
          randomLovelyPalette();
          const rect = container.getBoundingClientRect();
          const mx = mouse.inside ? mouse.x : rect.width * 0.5;
          const my = mouse.inside ? mouse.y : rect.height * 0.5;
          bloomAt(mx, my);
        }
      });
    </script>
  </body>
</html>
